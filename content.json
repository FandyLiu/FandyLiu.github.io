{"meta":{"title":"Fandy's Blog","subtitle":"吾日三省吾身","description":"wo ha ha","author":"Fandy","url":"https://fandyliu.github.io"},"pages":[],"posts":[{"title":"JSPatch 胡谈","slug":"aiOS/JSPatch胡谈","date":"2017-03-08T13:54:13.000Z","updated":"2017-03-09T14:31:17.000Z","comments":true,"path":"2017/03/08/aiOS/JSPatch胡谈/","link":"","permalink":"https://fandyliu.github.io/2017/03/08/aiOS/JSPatch胡谈/","excerpt":"今天早上一到公司，就收到苹果的一封邮件。相信大家都知道平常收到苹果的邮件肯定没有什么好事。于是在诚惶诚恐中打开了他，发现真不是什么好事。","text":"今天早上一到公司，就收到苹果的一封邮件。相信大家都知道平常收到苹果的邮件肯定没有什么好事。于是在诚惶诚恐中打开了他，发现真不是什么好事。 1234567891011Dear **,Your app, E+ 实名认证 (1116050607), does not comply with one or more App Review Guidelines.For details, or to directly contact the App Review team, go to the Resolution Center on iTunes Connect.Regards,App Store ReviewFind solutions and share tips with Apple developers from around the world — http://devforums.apple.com 他告诉我，我的 App 有一项或者多项不符合苹果的审核指南。顺手打开他给的链接到 iTunes Connect 中发现有一个违反政策通知问题。 123456789101112132017年3月8日 上午9:33发件人 AppleDear Developer,Your app, extension, and/or linked framework appears to contain code designed explicitly with the capability to change your app’s behavior or functionality after App Review approval, which is not in compliance with section 3.3.2 of the Apple Developer Program License Agreement and App Store Review Guideline 2.5.2. This code, combined with a remote resource, can facilitate significant changes to your app’s behavior compared to when it was initially reviewed for the App Store. While you may not be using this functionality currently, it has the potential to load private frameworks, private methods, and enable future feature changes. This includes any code which passes arbitrary parameters to dynamic methods such as dlopen(), dlsym(), respondsToSelector:, performSelector:, method_exchangeImplementations(), and running remote scripts in order to change app behavior or call SPI, based on the contents of the downloaded script. Even if the remote resource is not intentionally malicious, it could easily be hijacked via a Man In The Middle (MiTM) attack, which can pose a serious security vulnerability to users of your app.Please perform an in-depth review of your app and remove any code, frameworks, or SDKs that fall in line with the functionality described above before submitting the next update for your app for review.Best regards,App Store Review 说最新协议中，不允许使用动态下发功能，说这个有安全问题。 不明觉厉，苹果要禁止热更新？上年刚刚根据需求整合进去 JSPatch，今年就被禁用了。无语中。。。 想起一年前 2016 年初 JSPatch 安全问题 。 现在看样子苹果真的要下狠心禁用热更新了。 打开 github JSPatch/issues/746 和 react-native/issues/12778。有很多人对这个话题已经炒炸锅了，尤其是在 JSPatch 中。 看到不少人说 React Native 要被禁用了，而发出阵阵欢呼！ 但是我个人感觉，从苹果给的邮件可以看出他并不是针对 React Native 的，而是针对热更新的禁止。苹果一直希望上架的应用的可控性。但是热更新打破了这个事件。一些开发者，通过苹果审核上架后，通过动态下发新的功能，从而避过审核，调用私有 API 。这种行为是苹果严厉禁止的。 个人感觉热更新是个在移动端多年开发中的一个很不错的产物，通过这个功能可以加快对代码 中 bug 的解决速率，可以避免由于一个小小的问题而引起重新上架问题。而且苹果以前上架很慢，导致各公司很头痛，现在好多了。先不说上架慢这个问题，上架以后用户要更新吧，三两天一上架，那么就会提醒用户更新 App，这必然影响用户的体验。 当然我们公司的 App，并不会有这么快的上架频率，尽量将 bug 扼杀在开发、测试和预生产环节。这就要求公司的一些强大正规的开发体系支持了。对于小公司而言就没办法了，热更新对他们带来的方便是难以替代的。 但是苹果的性格大家都知道，说不能用就不能用。 对此我的态度是静观其变吧。 更新 2017-3-9 这里是 bang 对这个问题的回复： 关于苹果警告 这里是集成热更新的三方框架的处理情况汇总，大家可以看着排除一下，如果有用到那些可以及时更新。 三方框架处理进展 还是老老实实去除 JSPatch。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"JSPatch","slug":"JSPatch","permalink":"https://fandyliu.github.io/tags/JSPatch/"},{"name":"热更新","slug":"热更新","permalink":"https://fandyliu.github.io/tags/热更新/"},{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/tags/iOS/"}]},{"title":"URL Encode","slug":"aiOS/URLEncode","date":"2017-02-07T11:41:48.000Z","updated":"2017-02-11T07:41:27.000Z","comments":true,"path":"2017/02/07/aiOS/URLEncode/","link":"","permalink":"https://fandyliu.github.io/2017/02/07/aiOS/URLEncode/","excerpt":"URL 编码这个名词相信我们并不陌生，简单来说就是将一些字符转化为 “% + ASCII（16进制表示）” 的形式。 在开发中经常会遇到一些 URL 里面，有一些特殊的字符比如 ‘&amp;’、‘?’ 等等。由于这些字符在 URL 语法中有特殊含义，因此要对其进行 Encode。比如：在 1 个键值对中含有 &amp; ，name=fan&amp;dy=aa 注意这里是 1 个键值对，只是值中有 &amp; 和 = 所以我们要对 value 进行 URL 编码，转换为 name=fan%26dy%3Daa。 当然还有一种常见的情况就是在我们开发中对参数进行加密传输的时候，难免会出现一些特殊字符。比如 Base64 加密结果中的 ‘/’、‘=’ 等等。这个时候就要对其进行 URL 编码了。","text":"URL 编码这个名词相信我们并不陌生，简单来说就是将一些字符转化为 “% + ASCII（16进制表示）” 的形式。 在开发中经常会遇到一些 URL 里面，有一些特殊的字符比如 ‘&amp;’、‘?’ 等等。由于这些字符在 URL 语法中有特殊含义，因此要对其进行 Encode。比如：在 1 个键值对中含有 &amp; ，name=fan&amp;dy=aa 注意这里是 1 个键值对，只是值中有 &amp; 和 = 所以我们要对 value 进行 URL 编码，转换为 name=fan%26dy%3Daa。 当然还有一种常见的情况就是在我们开发中对参数进行加密传输的时候，难免会出现一些特殊字符。比如 Base64 加密结果中的 ‘/’、‘=’ 等等。这个时候就要对其进行 URL 编码了。 下面对 encode URL 进行总结： 在 Objective-C 中CFURLCreateStringByAddingPercentEscapes我们经常对 URL 采用 CFURLCreateStringByAddingPercentEscapes 函数进行 encode 处理。 这里是对其的静态函数的封装 12345678910static NSString * AFPercentEscapedQueryStringPairMemberFromStringWithEncoding(NSString *string, NSStringEncoding encoding) &#123; static NSString * const kAFCharactersToBeEscaped = @\":/?&amp;=;+!@#$()~',*\"; static NSString * const kAFCharactersToLeaveUnescaped = @\"[].\"; return (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (__bridge CFStringRef)string, (__bridge CFStringRef)kAFCharactersToLeaveUnescaped, (__bridge CFStringRef)kAFCharactersToBeEscaped, CFStringConvertNSStringEncodingToEncoding(encoding)));&#125; CFURLCreateStringByReplacingPercentEscapes我们也可以用 CFURLCreateStringByReplacingPercentEscapes 和 CFURLCreateStringByReplacingPercentEscapesUsingEncoding 函数对 URL 进行 decode 处理。 12345CFStringRef originalURLString = CFSTR(\"fan%25dy=aa\");NSString *preprocessedString = CFBridgingRelease(CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault, originalURLString, CFSTR(\"\"), kCFStringEncodingUTF8)); 这个是对上面函数第三个参数的描述： Pass NULL to specify that no percent escapes be replaced, or the empty string (CFSTR(“”)) to specify that all be replaced. 通常会在什么情况下使用呢？要对一个一半已经进行了 URL encode 而有部分却没有。因此直接进行 encode 的话会将 ‘%’ 转换为 ‘%25’ 导致错误，所以要先进行 decode 再进行 encode。如下： 12345678910111213141516171819202122CFStringRef originalURLString = CFSTR(\"fan%25dy=aa\");// decodeNSString *preprocessedString = CFBridgingRelease(CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault, originalURLString, CFSTR(\"\"), kCFStringEncodingUTF8));// encodeNSString *preprocessedUrlString = CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (__bridge CFStringRef)preprocessedString, NULL, CFSTR(\"?!@#$^&amp;%*+,:;='\\\"`&lt;&gt;()[]&#123;&#125;/\\\\| \"), kCFStringEncodingUTF8));// 直接encodeNSString *urlString = CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, originalURLString, NULL, CFSTR(\"?!@#$^&amp;%*+,:;='\\\"`&lt;&gt;()[]&#123;&#125;/\\\\| \"), kCFStringEncodingUTF8));NSLog(@\"preprocessedString = %@\", preprocessedString); // =&gt; fan%dy=aaNSLog(@\"preprocessedUrlString = %@\", preprocessedUrlString); // =&gt; fan%25dy%3DaaNSLog(@\"urlString = %@\", urlString); // =&gt; fan%2525dy%3Daa 上面的方法大多数在 iOS 9 的时候被废弃了，OC 提供了一些新的方法来替代。 stringByAddingPercentEncodingWithAllowedCharacters使用系统提供的 CharacterSet 来 encode URL1234NSString *originalString = @\"https://fandyliu.github.io/2016/12/02/Xcode提交构建版本时“此构建版本无效”问题/\";NSCharacterSet *customAllowedSet = [NSCharacterSet URLQueryAllowedCharacterSet];NSString *encodedUrl = [originalString stringByAddingPercentEncodingWithAllowedCharacters:customAllowedSet];NSLog(@\"encodedUrl = %@\", encodedUrl); 使用自定义的 CharacterSet 来 encode URL1234NSString *originalString = @\"https://fandyliu.github.io/2016/12/02/Xcode提交构建版本时“此构建版本无效”问题/\";NSCharacterSet *customAllowedSet = [[NSCharacterSet characterSetWithCharactersInString:@\" \\\"#%&lt;&gt;[\\\\]^`&#123;|&#125;\"] invertedSet];NSString *encodedUrl = [originalString stringByAddingPercentEncodingWithAllowedCharacters:customAllowedSet];NSLog(@\"encodedUrl = %@\", encodedUrl); 在 Swift 中 当然这么老掉牙的东西现在总结，主要还是整理一下她在 Swift 中的使用： 使用系统提供的 CharacterSet 来 encode URL123var originalString = \"https://fandyliu.github.io/2016/12/02/Xcode提交构建版本时“此构建版本无效”问题/\"var escapedString = originalString.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed)print(escapedString ?? \"error\") 使用自定义的 CharacterSet 来 encode URL1234var originalString = \"https://fandyliu.github.io/2016/12/02/Xcode提交构建版本时“此构建版本无效”问题/\"var customAllowedSet = CharacterSet(charactersIn: \" \\\"#%&lt;&gt;[\\\\]^`&#123;|&#125;\").invertedvar escapedString = originalString.addingPercentEncoding(withAllowedCharacters: customAllowedSet)print(escapedString ?? \"error\") 系统中提供 CharacterSet 的诸多值12345// 在 &apos;&apos; 中注意有空格，最外层 &apos;&apos; 为区分内容，不是 character CharacterSet 相反的 charactersCharacterSet.urlQueryAllowed &apos; &quot;#%&lt;&gt;[\\]^`&#123;|&#125;&apos; CharacterSet.urlHostAllowed &apos; &quot;#%/&lt;&gt;?@\\^`&#123;|&#125;&apos;CharacterSet.urlPathAllowed &apos; &quot;#%;&lt;&gt;?[\\]^`&#123;|&#125;&apos; 我们可以通过这个方法来打印系统中 CharacterSet 的 characters。（注意有些是带空格的） 1234567891011func printCharacters(in set: CharacterSet) &#123; var characters = \"\" let iSet = set.inverted for i: UInt32 in 32..&lt;127 &#123; let c = UnicodeScalar(i)! if iSet.contains(c) &#123; characters += String(c) &#125; &#125; print(\"'\\(characters)'\")&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"URL","slug":"URL","permalink":"https://fandyliu.github.io/tags/URL/"},{"name":"Encode","slug":"Encode","permalink":"https://fandyliu.github.io/tags/Encode/"}]},{"title":"Xcode 提交构建版本时 “此构建版本无效” 问题","slug":"aiOS/Xcode提交构建版本时“此构建版本无效”问题","date":"2016-12-02T08:43:49.000Z","updated":"2016-12-03T04:43:11.000Z","comments":true,"path":"2016/12/02/aiOS/Xcode提交构建版本时“此构建版本无效”问题/","link":"","permalink":"https://fandyliu.github.io/2016/12/02/aiOS/Xcode提交构建版本时“此构建版本无效”问题/","excerpt":"今天在提交构建版本到 appStore 的时候遇到了 “此构建版本无效”的提示！好吧，那么现在就把之前和今天遇到这个提示的可能原因做一下总结！","text":"今天在提交构建版本到 appStore 的时候遇到了 “此构建版本无效”的提示！好吧，那么现在就把之前和今天遇到这个提示的可能原因做一下总结！ 隐私权限描述不能没有内容从 iOS10 开始，苹果对用户的安全与隐私的保护进行了加强。在用到隐私权限的时候，需要在 info.plist 里面添加相应的权限描述。但是在之前则依旧会使用系统的权限通知框。 注意：如果你提交的应用里面只添加了权限，而没有后面的描述，就会造成”此构建版本无效“的问题，所以一定要把 key 和 value 都加上。 具体的权限设置可以参考 当然苹果也会给你发来一封邮件，邮件内容如下：1234567Dear developer,We have discovered one or more issues with your recent delivery for &quot;E+ 实名认证&quot;. To process your delivery, the following issues must be corrected:This app attempts to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.Once these issues have been corrected, you can then redeliver the corrected binary.Regards,The App Store team 苹果私有 API 的调用苹果同样也会给你发送邮件，注意查收一下。然后按邮件的提示进行问题的排查。如果你没有主动调用私有 API 的话，大部分情况下是由于程序当中的第三方 SDK 引起的。如果出现相应问题，可以重新向 SDK 供应商要一个没有调用苹果私有 API 的 SDK 。 如果没有收到邮件，也不要着急。道理是一样的，调用了私有 API。可以逐个排除第三方SDK，也可以询问他们的客服，毕竟不只是你一个人在用他们的SDK，因此说不一定有意外的收获。 目前来说支付宝和微信并没发现这个问题。 网上有遇到环信的 info.plist 文件问题的（听说删除就Ok了） 讯飞人脸识别问题的 在 Swift 项目中的一些问题： OC 中用 Swift 代码又删去 Invalid Swift Support / invalid implementation of swift 网络问题当出现了类似下边图片的错误时，那么很大可能就是网络的问题了！ 可以尝试重新提交几次，如果仍未解决可以尝试等一段时间后再进行提交，毕竟有可能是苹果服务器出 Bug。（可以在 iOS 交流群问问看看别人怎样，毕竟曾经我遇到过这种情况）","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"构建版本","slug":"构建版本","permalink":"https://fandyliu.github.io/tags/构建版本/"}]},{"title":"网络缓存","slug":"aiOS/网络缓存","date":"2016-11-15T02:03:26.000Z","updated":"2016-11-15T10:21:31.000Z","comments":true,"path":"2016/11/15/aiOS/网络缓存/","link":"","permalink":"https://fandyliu.github.io/2016/11/15/aiOS/网络缓存/","excerpt":"最近开发中遇到了一个网络缓存问题，在与 H5 交互的时候当创建 NSURLRequest 的时候调用 requestWithURL: cachePolicy: timeoutInterval: 这个方法设置缓存策略为默认的策略 NSURLRequestUseProtocolCachePolicy。 但当时调试与 H5 进行交互的一些 js 代码的时候， 修改 js 代码，手机 webView 访问没有变化，但是用浏览器打开 H5 界面确没有问题。最终发现是由于网络缓存问题，在这里简单总结一下缓存策略。","text":"最近开发中遇到了一个网络缓存问题，在与 H5 交互的时候当创建 NSURLRequest 的时候调用 requestWithURL: cachePolicy: timeoutInterval: 这个方法设置缓存策略为默认的策略 NSURLRequestUseProtocolCachePolicy。 但当时调试与 H5 进行交互的一些 js 代码的时候， 修改 js 代码，手机 webView 访问没有变化，但是用浏览器打开 H5 界面确没有问题。最终发现是由于网络缓存问题，在这里简单总结一下缓存策略。 使用缓存的目的是为了使用的应用程序能更快速的响应用户输入，是程序高效的运行。有时候我们需要将远程web服务器获取的数据缓存起来，减少对同一个url多次请求。 内存缓存我们可以使用 sdk 中的 NSURLCache 类。NSURLRequest 需要一个缓存参数来说明它请求的 url 何如缓存数据的，我们先看下它的 CachePolicy 类型。 NSURLRequestCachePolicyNSURLRequestUseProtocolCachePolicy = 0默认的缓存策略， 如果缓存不存在，直接从服务端获取。如果缓存存在，会根据response中的Cache-Control字段判断下一步操作，如: Cache-Control字段为must-revalidata，则询问服务端该数据是否有更新，无更新的话直接返回给用户缓存数据，若已更新，则请求服务端 NSURLRequestReloadIgnoringLocalCacheData = 1忽略本地缓存数据，直接请求服务端。 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4 (Unimplemented)忽略本地缓存，代理服务器以及其他中介，直接请求源服务端。 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData忽略本地缓存数据 NSURLRequestReturnCacheDataElseLoad = 2有缓存就使用，不管其有效性(即忽略Cache-Control字段)， 无则请求服务端。 NSURLRequestReturnCacheDataDontLoad = 3死活加载本地缓存。 没有就失败。 (确定当前无网络时使用) NSURLRequestReloadRevalidatingCacheData = 5 (Unimplemented)缓存数据必须得得到服务端确认有效才使用(貌似是NSURLRequestUseProtocolCachePolicy中的一种情况) HTTP 缓存语义HTTP 请求和回应用 headers 来交换元数据，如字符编码、MIME 类型和缓存指令等。 Request Cache Headers在默认情况下，NSURLRequest 会用当前时间决定是否返回缓存的数据。为了更精确地控制，允许使用以下请求头： If-Modified-Since - 这个请求头与 Last-Modified 回应头相对应。把这个值设为同一终端最后一次请求时返回的 Last-Modified 字段的值。 If-None-Match - 这个请求头与 Etag 回应头相对应。使用同一终端最后一次请求的 Etag 值。 Response Cache HeadersNSHTTPURLResponse 包含多个 HTTP 头，当然也包括以下指令来说明回应应当如何缓存： Cache-Control - 这个头必须由服务器端指定以开启客户端的 HTTP 缓存功能。这个头的值可能包含 max-age（缓存多久），是公共 public 还是私有 private，或者不缓存 no-cache 等信息。详情请参阅 Cache-Control section of RFC 2616。 除了 Cache-Control 以外，服务器也可能发送一些附加的头用于根据需要有条件地请求： Last-Modified - 这个头的值表明所请求的资源上次修改的时间。例如，一个客户端请求最近照片的时间线，/photos/timeline，Last-Modified 的值可以是最近一张照片的拍摄时间。 Etag - 这是 “entity tag” 的缩写，它是一个表示所请求资源的内容的标识符。在实践中，Etag 的值可以是类似于资源的 MD5 之类的东西。这对于那些动态生成的、可能没有明显的 Last-Modified 值的资源非常有用。 NSURLCacheNSURLCache 为您的应用的 URL 请求提供了内存中以及磁盘上的综合缓存机制。也就是 NSURLRequest，然后根据我们设置的NSURLCache策略进行相应的缓存. 当一个请求完成下载来自服务器的回应，一个缓存的回应将在本地保存。下一次同一个请求再发起时，本地保存的回应就会马上返回，不需要连接服务器。NSURLCache 会自动且透明地返回回应。 为了好好利用 NSURLCache，你需要初始化并设置一个共享的 URL 缓存。在 -application:didFinishLaunchingWithOptions: 中来设置内存缓存与磁盘缓存. 123NSURLCache *urlCache = [[NSURLCache alloc] initWithMemoryCapacity:4 * 1024 * 1024 diskCapacity:20 * 1024 * 1024 diskPath:nil];[NSURLCache setSharedURLCache:urlCache]; 缓存策略由请求（客户端）和回应（服务端）分别指定。理解这些策略以及它们如何相互影响，是为您的应用程序找到最佳行为的关键。 在 NSURLRequestCachePolicy 缓存策略中,默认策略是 UseProtocolCachePolicy 从字面上来看是说，使用协议缓存策略，但是什么是协议缓存策略呢？在HTTP协议的response头中，有一个字段是cache-control，由服务器来告诉客户端如何使用缓存。下面是一个response头 可以看到cache-control指定的行为是public,max-age=5这里先介绍一下各种指令 对应上表，可以看出了刚才响应头是要求缓存所有内容，缓存5秒失效，5秒后还要请求远程服务器。对应PHP就是header(“Cache-Control:public,max-age=5”); 本地缓存打开沙盒，发现在 Library/Caches 下面有三个文件这不就是sqlite么！原来NSURLCache帮我们用sqlite将请求存入了数据库，然后当有相同请求时就会调用缓存！可以想到webView如果加载一个静态页面不用只用请求一次，并且在效果要更新的时候远程请求会有多爽！ Tips:URL Loading System 默认只支持如下5中协议:其中只有http://和https://才有缓存策略。 http:// https:// ftp:// file:// data:// 链接:About the URL Loading System","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://fandyliu.github.io/tags/网络/"},{"name":"缓存","slug":"缓存","permalink":"https://fandyliu.github.io/tags/缓存/"},{"name":"NSURLRequestCachePolicy","slug":"NSURLRequestCachePolicy","permalink":"https://fandyliu.github.io/tags/NSURLRequestCachePolicy/"},{"name":"NSURLCache","slug":"NSURLCache","permalink":"https://fandyliu.github.io/tags/NSURLCache/"}]},{"title":"在 iOS 10 中如何跳转到系统设置页面？","slug":"aiOS/iOS10跳转系统设置页面","date":"2016-10-27T13:43:52.000Z","updated":"2016-11-01T10:22:11.000Z","comments":true,"path":"2016/10/27/aiOS/iOS10跳转系统设置页面/","link":"","permalink":"https://fandyliu.github.io/2016/10/27/aiOS/iOS10跳转系统设置页面/","excerpt":"跳转问题最近在适配 iOS 10 的时候，发现自己 app 在 iOS 10 系统下跳转到设置页面的时候并不会有任何跳转反应而打印出一些错误提示。但是在 iOS 9 及其以下版本并不会有这种情况。","text":"跳转问题最近在适配 iOS 10 的时候，发现自己 app 在 iOS 10 系统下跳转到设置页面的时候并不会有任何跳转反应而打印出一些错误提示。但是在 iOS 9 及其以下版本并不会有这种情况。 跳转代码如下： 12345NSURL *url = [NSURL URLWithString:@\"prefs:root=MOBILE_DATA_SETTINGS_ID\"];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 错误打印如下： 1-canOpenURL: failed for URL: &quot;prefs:root=MOBILE_DATA_SETTINGS_ID&quot; - error: &quot;The operation couldn’t be completed. (OSStatus error -10814.)&quot; 查阅实验初始通过搜索查阅发现有很多人的文章是这样子说的： 在iOS 9中，隐私控制已禁止开发者通过openURL:方法查询设备上是否安装了哪些APP应用。苹果禁止开发者查询设备上是否安装了某款APP。 如在 iOS10适配：被弃用的openURL 一文中。 但是通过在 stackoverflow 的搜索与自我研究实验最终发现并非如此。 结论分析其实在 iOS 10 中我们是可以通过 canOpenURL: 方法查询设备上是否安装了那 app 应用。只不过是 URL 的 scheme 有所变化。 iOS 10 把之前 prefs 开头的 URL Schemes 改成了 Prefs 开头，同样类似的还有 Mobilephone:// Clock-alarm:// Photos:// 等等（后面对其有总结）。把这个改好后在 Widget 里面确实可以使用了，但是在 app 中使用的时候依据会报如上类似的错误。这个时候需要在前面加上 App- 这是奇迹就发生了。 示例代码 12345NSURL *url = [NSURL URLWithString:@\"App-Prefs:root=MOBILE_DATA_SETTINGS_ID\"];if ([[UIApplication sharedApplication] canOpenURL:url])&#123; [[UIApplication sharedApplication] openURL:url];&#125; 些许扩展UIApplicationOpenSettingsURLString以前打开设置页面大多是通过这种方式打开，但是现在最低适配已经到 iOS 8 了这意味着什么? iOS 8 以前版本不用适配了。停止心中的喜悦，回归正题，其实在 iOS 8.0 的时候就推出了一种跳转到 app 自己设置页面的一个 String 那就是 UIApplicationOpenSettingsURLString 我们可以通过 1[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]]; 来实现跳转到本应用的设置界面进行设置。 openURL:options:completionHandler:在查看 openURL: 方法的时候无意中发现他已经被废弃了，而用另一个方法所代替。 123- (BOOL)openURL:(NSURL*)url NS_DEPRECATED_IOS(2_0, 10_0, \"Please use openURL:options:completionHandler: instead\") NS_EXTENSION_UNAVAILABLE_IOS(\"\"); 那么 openURL:options:completionHandler: 这个方法怎样使用呢？在官方文档 iOS UIKit 部分中介绍到 The new UIApplication method openURL:options:completionHandler:, which is executed asynchronously and calls the specified completion handler on the main queue (this method replaces openURL:). 意思就不解释了很容易理解 12345[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str] options:@&#123;UIApplicationOpenURLOptionUniversalLinksOnly:@YES&#125; completionHandler:^(BOOL success) &#123; // 判断打开成功与否回调处理 &#125;]; 这里对其简单的介绍，与 openURL: 功能类似，只是将 openURL: 返回的是否打开成功的布尔值写在回调中，并且添加了一个 options 参数，下面对 options 参数进行简单介绍。 options 是一个 NSDictionary&lt;NSString *, id&gt; * 这个类型的字典，目前在 UIApplication 头文件中，可传入参数 Key 只有一个 UIApplicationOpenURLOptionUniversalLinksOnly，其对应的 Value 为布尔值封装的 NSNumber 对象，默认为 False。官方文档是这个样子说的 the method opens the URL only if the URL is a valid universal link and there is an installed app capable of opening that URL. The value of this key is an NSNumber object containing a Boolean value. 也就是说只有在这个 URL 是有效，并且安装了该 app 的时候才能打开该 URL。否则就不能打开也就是回调的 success 的布尔值为 False，也就是不能通过Safari等其他应用来打开这个URL。 iOS 10 部分 Schemes电池电量 Prefs:root=BATTERY_USAGE通用设置 Prefs:root=General存储空间 Prefs:root=General&amp;path=STORAGE_ICLOUD_USAGE/DEVICE_STORAGE蜂窝数据 Prefs:root=MOBILE_DATA_SETTINGS_IDWi-Fi 设置 Prefs:root=WIFI蓝牙设置 Prefs:root=Bluetooth定位设置 Prefs:root=Privacy&amp;path=LOCATION辅助功能 Prefs:root=General&amp;path=ACCESSIBILITY关于手机 Prefs:root=General&amp;path=About键盘设置 Prefs:root=General&amp;path=Keyboard显示设置 Prefs:root=DISPLAY声音设置 Prefs:root=SoundsApp Store 设置 Prefs:root=STORE墙纸设置 Prefs:root=Wallpaper打开电话 Mobilephone://世界时钟 Clock-worldclock://闹钟 Clock-alarm://秒表 Clock-stopwatch://倒计时 Clock-timer://打开相册 Photos:// iOS 10 以前的 URL schemes","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"iOS 10","slug":"iOS-10","permalink":"https://fandyliu.github.io/tags/iOS-10/"},{"name":"openURL","slug":"openURL","permalink":"https://fandyliu.github.io/tags/openURL/"},{"name":"scheme","slug":"scheme","permalink":"https://fandyliu.github.io/tags/scheme/"}]},{"title":"Sequence 函数","slug":"aiOS/Sequence函数","date":"2016-10-01T07:34:56.000Z","updated":"2016-10-01T08:46:12.000Z","comments":true,"path":"2016/10/01/aiOS/Sequence函数/","link":"","permalink":"https://fandyliu.github.io/2016/10/01/aiOS/Sequence函数/","excerpt":"有些在 swift 1.0 为函数到 swift 2.0 变为一个对象的方法，Swift 3.0 并没有什么大变化,现在对 Sequence 函数这些方法做个总结.","text":"有些在 swift 1.0 为函数到 swift 2.0 变为一个对象的方法，Swift 3.0 并没有什么大变化,现在对 Sequence 函数这些方法做个总结. Sequence.contains()12345678910111213141516// 1. 简单的实用var b = [\"Swift\", \"Objective-C\"]// tureb.contains(\"Swift\")// 2. Swift 闭包和语法的灵活性let numbers = [1,2,3,4,5,6,7];// 如果数组中，有 3 的倍数，就返回 truenumbers.contains &#123; (element) -&gt; Bool in if element % 3 == 0 &#123; return true &#125;else &#123; return false &#125;&#125; 实例 123456789101112131415161718192021// 比如我们在维护一个图书列表，我们想知道这个列表中有没有图书有更新章节，可以用一个简单的模型来表示图书：class Book &#123; var title:String? var hasUpdate:Bool = false init(title:String, hasUpdate:Bool) &#123; self.title = title self.hasUpdate = hasUpdate &#125;&#125;// 然后，我们就可以用 predicate 的方式来直接进行判断了，不在需要 for 循环了：var bookList:[Book] = [Book]()bookList.append(Book(title:\"Objective-C\", hasUpdate:false))bookList.append(Book(title:\"Cocoa\", hasUpdate:false))bookList.append(Book(title:\"Swift\", hasUpdate:true))bookList.contains &#123; (book: Book) -&gt; Bool in return book.hasUpdate&#125; Sequence.enumerated()1234567891011121314151617var abc = [5, 7, 9]for (n, c) in abc.enumerated() &#123; print(\"\\(n): '\\(c)'\")&#125;// 0: '5'// 1: '7'// 2: '9'for (n, c) in \"Swift\".characters.enumerated() &#123; print(\"\\(n): '\\(c)'\")&#125;// Prints \"0: 'S'\"// Prints \"1: 'w'\"// Prints \"2: 'i'\"// Prints \"3: 'f'\"// Prints \"4: 't'\" 字符串截取12345let name = \"Marie Curie\"if let firstSpace = name.characters.index(of: \" \") &#123; let firstName = String(name.characters.prefix(upTo: firstSpace)) print(firstName)&#125; Sequence.sort()12345678let students: Set = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]let sortedStudents = students.sorted()print(sortedStudents)// Prints \"[\"Abena\", \"Akosua\", \"Kofi\", \"Kweku\", \"Peter\"]\"let descendingStudents = students.sorted(by: &gt;)print(descendingStudents)// Prints \"[\"Peter\", \"Kweku\", \"Kofi\", \"Akosua\", \"Abena\"]\" 例子12345678910111213141516171819202122enum HTTPResponse &#123; case ok case error(Int)&#125;let responses: [HTTPResponse] = [.error(500), .ok, .ok, .error(404), .error(403)]let sortedResponses = responses.sorted &#123; switch ($0, $1) &#123; // Order errors by code case let (.error(aCode), .error(bCode)): return aCode &lt; bCode // All successes are equivalent, so none is before any other case (.ok, .ok): return false // Order errors before successes case (.error, .ok): return true case (.ok, .error): return false &#125;&#125;print(sortedResponses)// Prints \"[.error(403), .error(404), .error(500), .ok, .ok]\" Sequence.dropFirst() Sequence.dropLast()12345678910// 1. Sequence.dropFirst()var languages = [\"Swift\", \"Objective-C\"]var oldLanguages = languages.dropFirst()// 2. Sequence.dropLast()let numbers = [1, 2, 3, 4, 5]print(numbers.dropLast(2))// Prints \"[1, 2, 3]\"print(numbers.dropLast(10))// Prints \"[]\" Sequence.filter12345678910// 1let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]let shortNames = cast.filter &#123; $0.characters.count &lt; 5 &#125;print(shortNames)// Prints \"[\"Kim\", \"Karl\"]\"// 2var arr = [0,1,2,3,4,5,6,7,8,9,10]let abc = arr.filter &#123; $0 % 2 == 0 &#125;// [0, 2, 4, 6, 8, 10] Sequence.index() Sequence.indices123456789101112131415let students = [\"Kofi\", \"Abena\", \"Peter\", \"Kweku\", \"Akosua\"]if let i = students.index(where: &#123; $0.hasPrefix(\"A\") &#125;) &#123; print(\"\\(students[i]) starts with 'A'!\")&#125;// Prints \"Abena starts with 'A'!\"var c = MyFancyCollection([10, 20, 30, 40, 50])var i = c.startIndexwhile i != c.endIndex &#123; c[i] /= 5 i = c.index(after: i)&#125;// c == MyFancyCollection([2, 4, 6, 8, 10]) Sequence.joined()1234let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]let list = cast.joined(separator: \", \")print(list)// Prints \"Vivien, Marlon, Kim, Karl\" Sequence.map12345let cast = [\"Vivien\", \"Marlon\", \"Kim\", \"Karl\"]let lowercaseNames = cast.map &#123; $0.lowercaseString &#125;// 'lowercaseNames' == [\"vivien\", \"marlon\", \"kim\", \"karl\"]let letterCounts = cast.map &#123; $0.characters.count &#125;// 'letterCounts' == [6, 6, 3, 4] Sequence.reduce1234567// 1let a = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"].reduce(\"\") &#123; $0 + $1 &#125;// 2let numbers = [1, 2, 3, 4]let addTwo: (Int, Int) -&gt; Int = &#123; x, y in x + y &#125;let numberSum = numbers.reduce(0, addTwo)// 'numberSum' == 10 Sequence.reduce1234567891011let numbers = [3, 5, 7]for number in numbers.reversed() &#123; print(number)&#125;// Prints \"7\"// Prints \"5\"// Prints \"3\"let reversedNumbers = Array(numbers.reversed())print(reversedNumbers)// Prints \"[7, 5, 3]\" Sequence.starts(with:)12345let a = 1...3let b = 1...10print(b.starts(with: a))// Prints \"true\"","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://fandyliu.github.io/tags/Swift/"},{"name":"函数","slug":"函数","permalink":"https://fandyliu.github.io/tags/函数/"}]},{"title":"Swift 访问修饰符","slug":"aiOS/Swift访问修饰符","date":"2016-09-27T10:27:29.000Z","updated":"2016-09-27T11:13:15.000Z","comments":true,"path":"2016/09/27/aiOS/Swift访问修饰符/","link":"","permalink":"https://fandyliu.github.io/2016/09/27/aiOS/Swift访问修饰符/","excerpt":"在 Swift 语言中，访问修饰符有五种，分别为 fileprivate，private，internal，public 和 open。 其中 fileprivate 和 open 是 Swift 3 新添加的。由于过去 Swift 对于访问权限的控制，不是基于类的，而是基于文件的。这样会有问题，所以Swift 3新增了两个修饰符对原来的 private、public 进行细分。","text":"在 Swift 语言中，访问修饰符有五种，分别为 fileprivate，private，internal，public 和 open。 其中 fileprivate 和 open 是 Swift 3 新添加的。由于过去 Swift 对于访问权限的控制，不是基于类的，而是基于文件的。这样会有问题，所以Swift 3新增了两个修饰符对原来的 private、public 进行细分。 各个修饰符区别private private 所修饰的属性或者方法只能在当前类里访问，类扩展和继承中都不能访问。 fileprivate fileprivate 所修饰的属性或者方法在当前的Swift源文件里可以访问。其他.swift文件中不能访问。 internal（默认访问级别，internal修饰符可写可不写） internal 所修饰的属性或方法在源代码所在的整个Module都可以访问。如果是框架或者库代码，则在整个框架内部都可以访问，框架由外部代码所引用时，则不可以访问。如果是App代码，也是在整个App内部可以访问。 open open 修饰的 class 在 Module 内部和外部都可以被访问和继承 open 修饰的 func 在 Module 内部和外部都可以被访问和重载（override）public public 修饰的 class 在 Module 内部可以访问和继承，在外部只能访问 public 修饰的 func 在 Module 内部可以被访问和重载（override）,在外部只能访问 final final 修饰的 class 任何地方都不能被继承 final 修饰的 func 任何地方都不能被 Override 5种修饰符访问权限排序现在的访问权限则依次为：open &gt; public &gt; interal &gt; fileprivate &gt; private 实例说明 open 和 publicModuleA.framework 中新建一个类ModuleA.swift 1234567891011121314151617181920212223242526272829303132import Foundation/// final的含义保持不变public final class FinalClass &#123; &#125;// 这个类在ModuleA的范围外是不能被继承的，只能被访问public class PublicClass &#123; public func testPublic() &#123;&#125; // 这是错误的写法，因为class已经不能被继承， // 所以他的方法的访问权限不能大于类的访问权限 open func testOpen() &#123;&#125; // final的含义保持不变 public final func testPublicFinal() &#123;&#125;&#125;// 在ModuleA的范围外可以被继承open class OpenClass &#123; // 这个属性在ModuleA的范围外不能被override public var size : Int = 0 // 这个方法在ModuleA的范围外不能被override public func testPublic() &#123;&#125; // 这个方法在任何地方都可以被override open func testOpen() &#123;&#125; ///final的含义保持不变 public final func testPublicFinal() &#123;&#125;&#125; 在 ModuleB.framework 中新建一个类：ModuleB.swift 并且把 ModuleA.framework import 进来 1234567891011121314151617181920212223242526272829import Foundationimport ModuleA// 这个写法是错误的，编译会失败,类访问权限标记的是public，只能被访问不能被继承class SubA : PublicClass &#123; &#125;// 这样写法可以通过,Class访问权限为 `open`.class SubB : OpenClass &#123; // 这样写也会编译失败,因为这个方法权限为public，不是`open'. override func testPublic() &#123; &#125; // 这个方法因为在SubclassableParentClass中标记为open，所以可以这样写 // 这里不需要再声明为open，因为这个类是internal的 override func testOpen() &#123; &#125;&#125;open class SubC : OpenClass &#123; // 这种写法会编译失败 override func testPublicFinal() &#123; &#125; // 正确的写法，方法也需要标记为open open override func testOpen() &#123; &#125;&#125;open class SubE : OpenClass &#123; // 也可以显式的指出这个方法不能再被override public final override func testOpen() &#123; &#125;&#125; 参考文章：没故事的卓同学","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://fandyliu.github.io/tags/Swift/"},{"name":"修饰符","slug":"修饰符","permalink":"https://fandyliu.github.io/tags/修饰符/"}]},{"title":"Xcode 8 屏蔽杂乱打印问题","slug":"aiOS/Xcode8屏蔽杂乱打印问题","date":"2016-09-24T07:34:56.000Z","updated":"2016-09-24T07:55:22.000Z","comments":true,"path":"2016/09/24/aiOS/Xcode8屏蔽杂乱打印问题/","link":"","permalink":"https://fandyliu.github.io/2016/09/24/aiOS/Xcode8屏蔽杂乱打印问题/","excerpt":"Xcode8总是打印一堆奇怪的东西。虽然不影响开发，但是看着很不爽。 现在对解决办法坐下记录。","text":"Xcode8总是打印一堆奇怪的东西。虽然不影响开发，但是看着很不爽。 现在对解决办法坐下记录。 Xcode8里边Edit Scheme-&gt; Run -&gt; Arguments， 在Environment Variables里边添加OS_ACTIVITY_MODE ＝ Disable 配置之后，一些像麦克风或者摄像头访问权限在 info.plist 中的一些key的配置可能不会打印提醒从而崩溃 项目打印提示类似于 1This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSSpeechRecognitionUsageDescription key with a string value explaining to the user how the app uses this data. 遇到这些问题可以去iOS10权限崩溃问题中查看如何配置","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://fandyliu.github.io/tags/Xcode/"},{"name":"Bug","slug":"Bug","permalink":"https://fandyliu.github.io/tags/Bug/"}]},{"title":"mutating关键字","slug":"aiOS/mutating关键字","date":"2016-09-24T07:02:10.000Z","updated":"2016-09-24T08:19:20.000Z","comments":true,"path":"2016/09/24/aiOS/mutating关键字/","link":"","permalink":"https://fandyliu.github.io/2016/09/24/aiOS/mutating关键字/","excerpt":"“Swift中protocol的功能比OC中强大很多，不仅能再class中实现，同时也适用于struct、enum。使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。”","text":"“Swift中protocol的功能比OC中强大很多，不仅能再class中实现，同时也适用于struct、enum。使用 mutating 关键字修饰方法是为了能在该方法中修改 struct 或是 enum 的变量，在设计接口的时候，也要考虑到使用者程序的扩展性。所以要多考虑使用mutating来修饰方法。” 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protocol ExampleProtocol &#123; var simpleDescription: String &#123; get &#125; mutating func adjust()&#125;class SimpleClass: ExampleProtocol &#123; var simpleDescription: String = \"A very simple class\" var anotherProperty: Int = 110 // 在 class 中实现带有mutating方法的接口时，不用mutating进行修饰。因为对于class来说，类的成员变量和方法都是透明的，所以不必使用 mutating 来进行修饰 func adjust() &#123; simpleDescription += \" Now 100% adjusted\" &#125;&#125;// 打印结果var a = SimpleClass()a.adjust()let aDescription = a.simpleDescriptionstruct SimpleStruct: ExampleProtocol &#123; var simpleDescription: String = \"A simple structure\" mutating func adjust() &#123; simpleDescription += \"(adjusted)\" &#125;&#125;enum SimpleEnum: ExampleProtocol &#123; case First, Second, Third var simpleDescription: String &#123; get &#123; switch self &#123; case .First: return \"first\" case .Second: return \"second\" case .Third: return \"third\" &#125; &#125; set &#123; simpleDescription = newValue &#125; &#125; mutating func adjust() &#123; &#125;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://fandyliu.github.io/tags/Swift/"},{"name":"关键字","slug":"关键字","permalink":"https://fandyliu.github.io/tags/关键字/"}]},{"title":"iOS 10 访问权限问题","slug":"aiOS/iOS10访问权限问题","date":"2016-09-20T07:34:56.000Z","updated":"2016-09-20T08:04:27.000Z","comments":true,"path":"2016/09/20/aiOS/iOS10访问权限问题/","link":"","permalink":"https://fandyliu.github.io/2016/09/20/aiOS/iOS10访问权限问题/","excerpt":"iOS 10 上，若你的项目访问了隐私数据，比如：相机，相册，通讯录等，都需要提前请求应用权限、允许后才可以使用，否则 app 会直接 Crash 了。还有Xcode 8 上传到 iTunesConnect 上的安装包提示无效二进制文件或者直接看不到。这是因为iOS10对用户的隐私做了进一步加强,在申请很多私有权限的时候都需要添加描述，这里我简单的记录了下解决方法。","text":"iOS 10 上，若你的项目访问了隐私数据，比如：相机，相册，通讯录等，都需要提前请求应用权限、允许后才可以使用，否则 app 会直接 Crash 了。还有Xcode 8 上传到 iTunesConnect 上的安装包提示无效二进制文件或者直接看不到。这是因为iOS10对用户的隐私做了进一步加强,在申请很多私有权限的时候都需要添加描述，这里我简单的记录了下解决方法。 方式一:在项目中找到info.plist文件。点击Information Property List 后边的加号，新添加一项。在新添加的key中输入 Privacy 可以迅速定位到这一权限系列，找到你需要的权限，修改后面的 value 就可以了（value内容可随意）。 1234567891011121314NSBluetoothPeripheralUsageDescription 访问蓝牙NSCalendarsUsageDescription 访问日历NSCameraUsageDescription 相机NSPhotoLibraryUsageDescription 相册NSContactsUsageDescription 通讯录NSLocationAlwaysUsageDescription 始终访问位置NSLocationUsageDescription 位置NSLocationWhenInUseUsageDescription 在使用期间访问位置NSMicrophoneUsageDescription 麦克风NSAppleMusicUsageDescription 访问媒体资料库NSHealthShareUsageDescription 访问健康分享NSHealthUpdateUsageDescription 访问健康更新NSMotionUsageDescription 访问运动与健身NSRemindersUsageDescription 访问提醒事项 方式二:在项目中找到info.plist文件。对其右击选Open As —&gt; Source Code，以Source Code形式打开。添加相应的键值对即可 1234567891011121314151617181920212223242526272829303132333435363738&lt;key&gt;NSVideoSubscriberAccountUsageDescription&lt;/key&gt; &lt;string&gt;视频认证&lt;/string&gt; &lt;key&gt;NSSpeechRecognitionUsageDescription&lt;/key&gt; &lt;string&gt;语音识别&lt;/string&gt; &lt;key&gt;NSSiriUsageDescription&lt;/key&gt; &lt;string&gt;Siri使用&lt;/string&gt; &lt;key&gt;NSRemindersUsageDescription&lt;/key&gt; &lt;string&gt;访问提醒事项&lt;/string&gt; &lt;key&gt;kTCCServiceMediaLibrary&lt;/key&gt; &lt;string&gt;TV控制&lt;/string&gt; &lt;key&gt;NSMotionUsageDescription&lt;/key&gt; &lt;string&gt;运动权限&lt;/string&gt; &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;麦克风权限&lt;/string&gt; &lt;key&gt;NSAppleMusicUsageDescription&lt;/key&gt; &lt;string&gt;苹果音乐&lt;/string&gt; &lt;key&gt;NSLocationUsageDescription&lt;/key&gt; &lt;string&gt;位置权限&lt;/string&gt; &lt;key&gt;NSHomeKitUsageDescription&lt;/key&gt; &lt;string&gt;HomeKit权限&lt;/string&gt; &lt;key&gt;NSHealthUpdateUsageDescription&lt;/key&gt; &lt;string&gt;健康应用&lt;/string&gt; &lt;key&gt;NSHealthShareUsageDescription&lt;/key&gt; &lt;string&gt;健康应用&lt;/string&gt; &lt;key&gt;NSContactsUsageDescription&lt;/key&gt; &lt;string&gt;通讯录&lt;/string&gt; &lt;key&gt;NSCalendarsUsageDescription&lt;/key&gt; &lt;string&gt;日历&lt;/string&gt; &lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; &lt;string&gt;蓝牙&lt;/string&gt; &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; &lt;string&gt;相册&lt;/string&gt; &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;相机&lt;/string&gt; &lt;key&gt;NSLocationAlwaysUsageDescription&lt;/key&gt; &lt;string&gt;永久使用定位&lt;/string&gt; &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt; &lt;string&gt;应用使用的时候使用定位&lt;/string&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://fandyliu.github.io/tags/Xcode/"},{"name":"Bug","slug":"Bug","permalink":"https://fandyliu.github.io/tags/Bug/"},{"name":"权限","slug":"权限","permalink":"https://fandyliu.github.io/tags/权限/"}]},{"title":"RubyGems 镜像","slug":"aiOS/RubyGems镜像","date":"2016-07-25T07:42:20.000Z","updated":"2016-07-25T08:21:12.000Z","comments":true,"path":"2016/07/25/aiOS/RubyGems镜像/","link":"","permalink":"https://fandyliu.github.io/2016/07/25/aiOS/RubyGems镜像/","excerpt":"由于国内不能访问官方的 Ruby 源，所以有些大牛搭建了 ruby.taobao.org 为国内开发者解决 Gem 安装的问题，但是由于各种原因使 ruby.taobao.org 很难同步了、和维护。最终他们考虑由 Ruby China 来负责这个事情，这样可以像现在 Ruby China 社区，RubyConf China 一样，由社区的很多参与者来共同维护。","text":"由于国内不能访问官方的 Ruby 源，所以有些大牛搭建了 ruby.taobao.org 为国内开发者解决 Gem 安装的问题，但是由于各种原因使 ruby.taobao.org 很难同步了、和维护。最终他们考虑由 Ruby China 来负责这个事情，这样可以像现在 Ruby China 社区，RubyConf China 一样，由社区的很多参与者来共同维护。 更换数据源1234$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/$ gem sources -lhttps://gems.ruby-china.org# 确保只有 gems.ruby-china.org RVM 安装脚本的方式安装 Ruby123456789101112131415161718192021222324252627echo &quot;Install RVM&quot;echo &quot;---------------------------------------------------------------------------&quot;command gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3command curl -L https://get.rvm.io | bash -s stableif [ whoami = &apos;root&apos;]; thencommand source /etc/profile.d/rvm.shelsecommand source ~/.rvm/scripts/rvmfiif [ MIRROR = &apos;1&apos; ]; thenecho &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/dbfirvm requirementsrvm install 2.3.1 --disable-binaryrvm use 2.3.1 --defaultrvm -vruby -vif [ MIRROR = &apos;1&apos; ]; thengem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/figem install bundlerbundle -vecho &quot;--------------------------- Install Successed -----------------------------&quot; 地址链接： RubyGems 镜像源 使用方法","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"https://fandyliu.github.io/tags/Ruby/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://fandyliu.github.io/tags/CocoaPods/"}]},{"title":"在 Xcode 中的 iPhone 模拟器的 CPU 与真机的 CPU 的区别","slug":"aiOS/在Xcode中的iPhone模拟器的cpu与真机的cpu的区别","date":"2015-10-07T03:39:15.000Z","updated":"2015-10-07T07:27:33.000Z","comments":true,"path":"2015/10/07/aiOS/在Xcode中的iPhone模拟器的cpu与真机的cpu的区别/","link":"","permalink":"https://fandyliu.github.io/2015/10/07/aiOS/在Xcode中的iPhone模拟器的cpu与真机的cpu的区别/","excerpt":"ARM 处理器，因其功耗低和尺寸小而闻名，几乎所有的手机处理器都基于ARM，苹果当然也不例外。","text":"ARM 处理器，因其功耗低和尺寸小而闻名，几乎所有的手机处理器都基于ARM，苹果当然也不例外。 armv6、armv7、armv7s、arm64都是ARM处理器的指令集，所有指令集原则上都是向下兼容的。如 iPhone 4s 的CPU默认指令集为 armv7 指令集，但它可以同时也兼容 armv6 的指令集，只是在使用 armv6 的时候无法充分发挥其性能(无法发挥 armv7 指令集中得新特性)。iOS 模拟器没有运行 ARM 指令集，编译运行的是 x86 指令集(或 i386 )，所以只有在 iOS 设备上才会执行设备对应 ARM 指令集。 设备的CPU架构(指令集)模拟器: 模拟器设备 CPU架构 4s-5 i386 5s-6s Plus x86_64 真机(iOS设备): armv6: iPhone、iPhone 2、iPhone 3G、iPod Touch(第一代)、iPod Touch(第二代) armv7: iPhone 3Gs、iPhone 4、iPhone 4s、iPad、iPad 2 armv7s: iPhone 5、iPhone 5c (静态库只要支持了armv7，就可以在armv7s的架构上运行) arm64(注:无armv64): iPhone 5s、iPhone 6、iPhone 6 Plus、iPhone 6s、iPhone 6s Plus、iPad Air、iPad Air2、iPad mini2、iPad mini3 Xcode配置 各个参数Architectures:指明选定的Target要求被编译生成的二进制包所支持的指令集，支持指令集是通过编译生成对应的二进制数据包实现的。如果支持的指令集数目有多个，就会编译出包含多个指令集代码的数据包，从而造成最终编译生成的包很大。 Valid Architectures:指明可能支持的指令集并非Architectures列表中指明的指令集都会被支持，Valid Architectures限制可能被支持的指令集的范围，即Valid Architectures 和 Architectures 列表的交集，才是Xcode最终生成二进制包所支持的指令集。 比如:将Architectures支持arm指令集设置为: armv7， armv7s，对应的Valid Architectures的支持的指令集设置为:armv7s，arm64，那么此时Xcode生成二进制包所支持的指令集只有armv7s。 Build Active Architecture Only：指明是否只编译当前连接设备所支持的指令集。该选项起作用的条件有两个，必须同时满足才会起作用 其值设置为 YES Xcode 成功连接调试设备假定我们将Build Active Architecture Only值设置为YES，同时Xcode连接上手机 iPhone 5s（匹配指令集arm64）Build Active Architecture Only 实例 第一种情况Architectures: armv7， armv7s， arm64Valid Architectures: armv6， armv7s， arm64生成二进制包支持的指令集： arm64 第二种情况Architectures: armv6， armv7， armv7sValid Architectures: armv6， armv7s， arm64生成二进制包支持的指令集： armv7s 第三种情况Architectures: armv6， armv7Valid Architectures: armv6， armv7s， arm64生成二进制包支持的指令集： armv7 第四种情况Architectures: armv6Valid Architectures: armv6， armv7s， arm64生成二进制包支持的指令集： 虽然编译成功了，但是并没有任何目标生成， 因为从XCode4.5开始，就不再支持armv6指令集，所以列表中写了也是白写。 第五种情况Architectures: armv7， armv7s， arm64Valid Architectures: armv7，armv7s生成二进制包支持的指令集： 编译出错信息 1No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=arm64, VALID_ARCHS=armv7 armv7s) 可以看出：当Build Active Architecture Only起作用时：连接的手机指令集匹配是由高到低（arm64 &gt; armv7s &gt; armv7）依次匹配的。 如连接手机为iPhone 5s，其默认指令集为arm64，若Architectures列表为armv7， armv7s，则会选取armv7s指令集为目标指令集，如果此时Valid Architectures列表中包含该指令集，则成功生成的二进制包只支持armv7s指令集，若Valid Architectures列表不包含此指令集，则编译将会出错： 1No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 arm64) 同样的，若Architectures列表为armv7，则会选取armv7作为目标指令集，若Valid Architectures列表中包含了armv7指令集，则能够成功生成二进制包，其支持的指令集只有armv7，若Valid Architectures列表中不包含armv7，则编译失败。 建议：通常Debug模式设置值为Yes，Release模式设置为No。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"https://fandyliu.github.io/tags/Xcode/"},{"name":"Bug","slug":"Bug","permalink":"https://fandyliu.github.io/tags/Bug/"},{"name":"模拟器","slug":"模拟器","permalink":"https://fandyliu.github.io/tags/模拟器/"},{"name":"CPU架构","slug":"CPU架构","permalink":"https://fandyliu.github.io/tags/CPU架构/"}]},{"title":"Swift 中的一些函数","slug":"aiOS/Swift中的一些函数","date":"2015-10-01T04:02:10.000Z","updated":"2015-10-01T06:15:58.000Z","comments":true,"path":"2015/10/01/aiOS/Swift中的一些函数/","link":"","permalink":"https://fandyliu.github.io/2015/10/01/aiOS/Swift中的一些函数/","excerpt":"Swift中一些简单函数的总结","text":"Swift中一些简单函数的总结 一些函数 sequence 12345678// 创建一个序列（Sequence）来表示填充的数据// 有很多的方法去创建序列，但是重载的 sequence() 函数可能是最简单的方式。var a = [1, 2]a.reserveCapacity(256)a += sequence(first: 3, next: &#123;$0 &lt; 1000 ? ($0 + 3) * 2 : nil&#125;) assert 12// 参数如果为`true`则继续，否则抛出异常assert(true) enumerate 1234567891011// 第一个值为原来元素所在的位置`index`，第二个为原来序列中的元素// unresolved identifier 'enumerate' swift 3.0for (i, j) in enumerate([\"A\", \"B\"]) &#123; // \"0:A\", \"1:B\" will be printed println(\"\\(i):\\(j)\")&#125; zip 1234567891011121314151617181920212223242526272829303132// 1let words = [\"one\", \"two\", \"three\", \"four\"]let numbers = 1...4for (word, number) in zip(words, numbers) &#123; print(\"\\(word): \\(number)\")&#125;// Prints \"one: 1\"// Prints \"two: 2// Prints \"three: 3\"// Prints \"four: 4\"let naturalNumbers = 1...Int.maxlet zipped = Array(zip(words, naturalNumbers))// zipped == [(\"one\", 1), (\"two\", 2), (\"three\", 3), (\"four\", 4)]// 2let names: Set = [\"Sofia\", \"Camilla\", \"Martina\", \"Mateo\", \"Nicolás\"]var shorterIndices: [SetIndex&lt;String&gt;] = []for (i, name) in zip(names.indices, names) &#123; if name.characters.count &lt;= 5 &#123; shorterIndices.append(i) &#125;&#125;for i in shorterIndices &#123; print(names[i])&#125;// Prints \"Sofia\"// Prints \"Mateo\" min max 12345// 2min(8, 2, 3)// 8max(8, 2, 3) sort 排序 1234567for i in sort([\"B\", \"A\"]) &#123; // \"A\", \"B\" will be printed println(i)&#125; abs(signedNumber)：返回数字的绝对值 12345abs(-1) == 1abs(-42) == 42abs(42) == 42 dump(object)：打印出某个对象object的所有信息 123456789101112var languages = [\"Swift\", \"Objective-C\"]dump(languages)// Prints:// ▿ 2 elements// - [0]: Swift// - [1]: Objective-C","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://fandyliu.github.io/tags/Swift/"},{"name":"函数","slug":"函数","permalink":"https://fandyliu.github.io/tags/函数/"}]},{"title":"图层树","slug":"图层树","date":"2015-05-10T15:24:48.000Z","updated":"2015-05-10T15:24:48.000Z","comments":true,"path":"2015/05/10/图层树/","link":"","permalink":"https://fandyliu.github.io/2015/05/10/图层树/","excerpt":"","text":"图层与视图","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"图层","slug":"图层","permalink":"https://fandyliu.github.io/tags/图层/"},{"name":"tag2","slug":"tag2","permalink":"https://fandyliu.github.io/tags/tag2/"}]},{"title":"UIWebView 禁止长按链接弹出选择栏","slug":"aiOS/UIWebView禁止长按链接弹出选择栏","date":"2015-02-09T10:03:34.000Z","updated":"2015-02-09T11:13:22.000Z","comments":true,"path":"2015/02/09/aiOS/UIWebView禁止长按链接弹出选择栏/","link":"","permalink":"https://fandyliu.github.io/2015/02/09/aiOS/UIWebView禁止长按链接弹出选择栏/","excerpt":"当 webview 显示 html 页面的时候，其本身会提供一些原生的交互行为：长按获取文本，或者链接。如何禁用这个效果呢。现在总结几种方案:","text":"当 webview 显示 html 页面的时候，其本身会提供一些原生的交互行为：长按获取文本，或者链接。如何禁用这个效果呢。现在总结几种方案: 方式一通过Webkit内核提供的一些特殊的CSS属性 ，我们可以很方便的禁用掉这些默认的行为。首先我们介绍两个特殊的CSS属性。 -webkit-touch-callout -webkit-touch-callout(IOS2.0及以后可用)Disables the default callout shown when you touch and hold a touch target. Syntax-webkit-touch-callout: behavior; 长按诸如链接的目标对象时，是否允许呼出默认的popOver，当前选择值包括: none:不呼出弹窗框 inherit:可以呼出弹窗框 在IOS中，当你touch和hold一个触控对象时，例如链接，Safari会显示一个包含链接信息的弹出框。该属性允许你来禁用这个弹出框。 -webkit-user-select -webkit-user-select(IOS3.0及以后可用)Determines whether a user can select the content of an element. Syntax-webkit-user-select: policy; 是否允许用户选择元素的内容，选择值包括： auto:用户可以选择元素内的内容 none:用户不能选择任何内容 text:用户只能选择元素内的文本 禁用整个页面的用户选择和链接弹出框，可页面样式表中添加如下样式规则12345body.disable-default-action&#123; -webkit-touch-callout:none ; -webkit-user-select:none ;&#125; 同时在body标签中加入该类型,如 123&lt;body class = &quot;disable-default-action&quot;&gt; page content….&lt;/body&gt; 只允许Form表单域执行文本的剪切板操作，添加如下规则1234 *:not(input,textarea) &#123; -webkit-touch-callout: none; -webkit-user-select: none; &#125; 禁用某个链接的长按弹出框,可在链接添加内联样式规则如下1&lt;a href=&quot;http://www.baidu.com&quot; style = &quot;-webkit-touch-callout:none&quot;&gt; 方式二以编程方式动态的向加载页面添加样式来达到同样的效果(iOS 8 以前可以用 以后貌似不可以) 实现UIWebviewDelegate协议，在webViewDidFinishLoad:方法中添加以下代码 1234567- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; // 禁用用户选择 [webView stringByEvaluatingJavaScriptFromString:@\"document.documentElement.style.webkitUserSelect='none';\"]; // 禁用长按弹出框 [webView stringByEvaluatingJavaScriptFromString:@\"document.documentElement.style.webkitTouchCallout='none';\"];&#125; html５ 貌似可以这样子加(没有测试过)1document.body.style.webkitTouchCallout='none' 方式三更安全的方式是，写html的时候加上以下代码，这样不管谁调用你的网页，长按链接都不会呼出弹窗框12345&lt;script type=&quot;text/javascript&quot;&gt; window.onload=function()&#123; document.documentElement.style.webkitTouchCallout=&apos;none&apos;; &#125;; &lt;/script&gt; 这样子不管谁调用都没有这个手势了 方式四用个chang在viewdidload或适当的地方创建一个自定义的长按手势 1234567UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:nil];// 记得在.h文件里加上委托longPress.delegate = self;// 这里为什么要设置0.4，因为只要大于0.5就无效，我像大概是因为默认的跳出放大镜的手势的长按时间是0.5秒，// 如果我们自定义的手势大于或小于0.5秒的话就来不及替换他的默认手势了，这是只是我的猜测。但是最好大于0.2秒，因为有的pdf有一些书签跳转功能，这个值太小的话可能会使这些功能失效。longPress.minimumPressDuration = 0.4;[self.webView addGestureRecognizer:longPress]; 接下来就是实现一个委托了 12345#pragma mark - GestureRecognizerDelegate- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; return NO; &#125; 其他参考连接","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"UIWebView","slug":"UIWebView","permalink":"https://fandyliu.github.io/tags/UIWebView/"},{"name":"手势","slug":"手势","permalink":"https://fandyliu.github.io/tags/手势/"}]},{"title":"GitHub Summary","slug":"aiOS/GitHub-Summary","date":"2015-01-22T20:22:19.000Z","updated":"2017-02-22T06:46:41.000Z","comments":true,"path":"2015/01/23/aiOS/GitHub-Summary/","link":"","permalink":"https://fandyliu.github.io/2015/01/23/aiOS/GitHub-Summary/","excerpt":"","text":"SimulatorStatusMagic 模拟器中修改状态条","categories":[{"name":"iOS","slug":"iOS","permalink":"https://fandyliu.github.io/categories/iOS/"}],"tags":[{"name":"github","slug":"github","permalink":"https://fandyliu.github.io/tags/github/"},{"name":"repo","slug":"repo","permalink":"https://fandyliu.github.io/tags/repo/"}]},{"title":"Java 基本语法","slug":"Java/Java基本语法","date":"2014-04-24T14:00:38.000Z","updated":"2014-04-24T15:10:42.000Z","comments":true,"path":"2014/04/24/Java/Java基本语法/","link":"","permalink":"https://fandyliu.github.io/2014/04/24/Java/Java基本语法/","excerpt":"Java基本语法: Java 语言严格区分大小写，好比 main 和 Main 是完全不同的概念。 一个 Java 源文件里可以定义多个 Java 类，但其中最多有一个类被定义成 public 类。若源文件中包括了 public 类，源文件必须和该 public 类同名（没有源文件名随便起）。 一个源文件中包含 N 个 Java 类时，编译后会生成 N 份字节码文件，即每个类都会生成一份单独的 .class文件，且字节码文件名和其对应的类名相同。 每一个类必须拥有 main 方法才能运行,因为 main 方法是程序的入口。","text":"Java基本语法: Java 语言严格区分大小写，好比 main 和 Main 是完全不同的概念。 一个 Java 源文件里可以定义多个 Java 类，但其中最多有一个类被定义成 public 类。若源文件中包括了 public 类，源文件必须和该 public 类同名（没有源文件名随便起）。 一个源文件中包含 N 个 Java 类时，编译后会生成 N 份字节码文件，即每个类都会生成一份单独的 .class文件，且字节码文件名和其对应的类名相同。 每一个类必须拥有 main 方法才能运行,因为 main 方法是程序的入口。 关键字与保留字 关键字：在编程语言中有一些事先定义的，有着特殊含义和用途的单词。 保留字：和关键字一样都是编程语言事先定义好的，只是说现在暂时没有特殊的用途，但说不定以后某天会突然被赋予意义和被使用到，因此被保留下来的单词。 注意：关键字和保留字都是由小写字母组成。 java 无 sizeof 、goto、 const 关键字。 变量与常量 常量：程序中固定不变化的值。分为两类： 字面量：一个写死的固定不变的值。 final修饰的变量。 变量的定义:在程序执行的过程中，其值在某个范围内可以改变的量，可以理解为数学中的未知数。 数据类型Java是强类型的语言，对于每一种数据都定义了明确的数据类型。 基本数据类型，又称为原生数据类型； 引用数据类型，又称为对象数据类型，包括类，接口，数组； 基本数据类型 默认情况下，一个整型的字面量是 int 类型。若要声明一个 long 型字面量，字面量后加上 l 或 L，因小写的 l 容易和数字 1 相混淆，建议使用大写 L。当然赋值给 short 和 byte 类型变量的时候有隐式转换所以不会报错。 默认情况下，一个浮点型的字面量是 double 类型。若要声明一个 float 型字面量，则需在常量后加上 f 或 F，double 常量后面的 D 或 d 可省略。 因为 float 和 double 都不能精确的表示小数，那么在精度要求高的系统比如银行系统里，要用 BigDecimal 类型，它能表示任意精度的数据。 char类型：只能存储 1 个字符，Java 对字符采用 Unicode 字符编码。Unicode 收集了世界上各国语言文字中的字符，是一种跨平台的编码方式，Java的字符占两个字节，可以表示一个汉字。 char 类型本质其实也是整数。 ASCII 表对应 0-48、A-65、a-97 String字符串拼接: 字符串和任意数据类型相连接，结果都是字符串类型。 运算表达式自动类型提升 在做运算的时候所有的 byte、short、char 类型被自动提升到 int 类型 整个表达式的最终结果类型被提升到表达式中类型最高的类型 运算特例 当整数除以 0 的时候：会引发算术异常； 正无穷大(Infinity)：正整数除以 0.0 时； 负无穷大(-Infinity)：负整数除以 0.0 时； NaN(Not a Number)：当 0.0 除以 0.0 时，或者当一个正浮点类型数除以 0 时，或者当一个负浮点类型数除以 0 时； 注意：无穷大和 NaN 都属于 double 浮点类型，但是所有正无穷大都是相等的，所有负无穷大也是相等的，NaN永远不相等，也不等于自己。 +=加等于：x += 5; 相当于 x = x + 5，但还包括隐式类型转换。 逻辑运算符 &amp;：表示并且，当操作数 A 和 B 都为 true 结果才为 true，否则结果 result 是 false。 &amp;&amp;：和 &amp; 结果相同，具有短路效果，如果左边操作数 A 是 false，result 一定为 false，且不运行B的运算。 |：表示或者，A 和 B 都为 false 结果 result 为 false，只要有 A 或 B 是 true，结果就是 true。 ||：和 | 结果相同，具有短路效果，如果左边操作数 A 是 true，result 一定为 true，且不运行 B 的运算。 ^：判断 A 和 B 是否不同，不同则为true，相同则为false。 !：取反，!true 结果是 false，!fasle 结果是 true。 位运算符 &amp;：参与运算的两个数，若相应位数的值都为 1，则该位结果值是 1，否则是 0。 |：参与运算的两个数相应位中只要有一个 1，结果就是1 。 ^：参与运算的两个数相应位相同则结果为 0，否则为 1。 ~ ：表示把每个二进制位的“1”换成“0”，把“0”换成“1”。 &lt;&lt;：将操作数的二进制码整体左移指定位数，左移之后的空使用“0”来补充。 &gt;&gt;：将操作数的二进制码整体右移指定位数，右移之后的空使用“符号位”来补充： &gt;&gt;&gt;：将操作数的二进制码整体右移指定位数，右移之后的空位使用“0”来补充。 循环中运算终止语句break：结束当前所在循环continue：结束当前这次循环，继续下次循环return：结束所在的方法，方法都结束了，循环结构自然也就结束了。 在循环嵌套中，单独控制外层循环该怎么做？此时就得使用标签了，标签就是给某个循环起的别名，不过该别名得满足标识符的规范。若要控制外层循环,就在break或continue后面跟上循环的别名就OK了 如: break &lt;标签名&gt;; 方法的重载方法的重载：在同一个类中，允许多个方法的名字相同，但是他们的参数列表绝对不能相同。 这种设计遵守的原则：两同一不同。两同：同一个类，方法名相同。一不同：形参列表不同。 注意：方法重载和方法的返回值类型无关。 数组面向对象三大特征：封装(Encapsulation)；继承(Inheritance)；多态(Polymorphism)； 封装是指将对象的实现细节隐藏起来，然后通过公共的方法来向外暴露该对象的功能。继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类是一种特殊的父类，能直接或间接获得父类里的成员。多态是可以直接把子类对象赋给父类变量，但是运行时依然表现出子类的行为特征，这意味着同一类型的对象在运行时可能表现出不同的行为特征。 注意： 面向对象是基于面向过程的 构造方法构造器特点:1.方法名与类名相同：这样我们才知道当前创建的是哪个类型的实例。2.不用定义返回值类型：这个方法就是初始化该对象的数据，因为要返回肯定就是自身的类型。3.可以写return语句，但是不能跟有值：因为要返回的一定是初始化好的对象。 当一个类中没有显示定义构造器时,那么编译器会默认给该类提供一个构造器，其特点是：无参、空方法体、访问修饰符和所在类的访问修饰符相同。 在类中一旦显示 修饰符staticstatic修饰符表示静态的，固定的，可修饰字段、方法、内部类，其修饰的成员属于类,也就是说static修饰的资源属于类级别,而不是对象级别。 特点：1.随着类的加载而加载(其生命周期和类一样长)：随着人类产生的同时，人类也就有了文明前进的行为。2.优先于对象存在：类成员是字节码被加载进JVM时就存在了，而对象时后来new出来的。3.被所有对象所共享：既然是人类具备的行为特征，那么每一个人对象也应该具备。4.可以直接被类名调用：类成员直接属于某一类事物,那么就应该让该类事物来直接调用。 使用static修饰的字段不是存储在堆内存的，而是存储在独立于堆内存和栈内存的方法区内存中，可以被该类所有的对象所共享。 EclipseEclipse介绍:一款使用Java语言编写的基于插件的IDE(集成开发环境)工具 jar一.命令行制作方式jar命令格式：jar {c t x u f }[ v m e 0 M i ][-C 目录]文件名…其中{ctxu}这四个参数至少选其一。[v f m e 0 M i ]是可选参数，文件名也是必须的。 一般使用: jar cvf 文件名.jar 类全名 jar cvf 文件名.jar -C StringString对象比较:1）：单独使用””引号创建的字符串都是直接量,编译期就已经确定存储到常量池中；2）：使用new String(“”)创建的对象会存储到堆内存中,是运行期才创建；3）：使用只包含直接量的字符串连接符如”aa” + “bb”创建的也是直接量编译期就能确定,已经确定存储到常量池中；4）：使用包含String直接量(无final修饰符)的字符串表达式(如”aa” + s1)创建的对象是运行期才创建的,存储在堆中； String对象. -----&gt;不擅长做字符串的连接操作,性能太低. 解决方案: 使用可变的字符串,内容改变之后,对象依然不变.StringBuidler/StringBuffer:——面试——————-StringBuffer :特点: 线程安全性较高,但是性能较低. 多线程使用StringBuffer.StringBuilder :特点: 线程安全性较低,当时性能较高. 推荐 单线程使用StringBuilder. package语句编译和运行带有包名的类编译带包名的java文件：必须要使用参数: -d 文件夹javac -d . Hello.java import语句语法1： import 类的全限定名;import 完整包名.类名;语法2:import java.util.*; 表示去java.util包下寻找被使用到的类。静态导入：告诉编译器去哪一个包下的指定的类中去找某个静态方法或字段。语法1： import static 类的全限定名.静态成员;import static java.lang.Math.PI;import static java.lang.Math.max;语法2:import static java.lang.Math.;表示去java.lang.Math类中寻找被使用到的静态成员。注意： 只能表示静态成员，不能表示实例成员。静态导入的可读性差,一般很少用,大家了解用法即可 访问权限修饰符① private(类私有)：本类内部可以访问，同包内不能访问，不能被子类继承。② 无(包私有)：本类内部可以访问，同包其他类也可以访问，能被同包的子类继承。不同包子类不能继承和访问。③ protected（包和子类私有）：本类内部可以访问，不同包的子类也可以访问，同包其他类也可以访问，能被子类所继承。④ public(公共)：任何地方都可以访问，能继承到子类。注意：类的访问修饰符只有 public和缺省，即public class A{}或者class A{} final本身的含义是“不可改变的/最终的”，它可以修饰非抽象类，非抽象方法和变量。 注意：构造方法不能使用final修饰，因为构造方法不能被继承，肯定是最终的。 什么时候把方法设计成final的呢？1.在构造器里调用的初始化方法。2.只想被子类调用，不想被子类复写的方法，如：父类提供基本业务算法 常量名规范：常量名符合标识符，单词全部大写，单词间使用”_”(下划线)隔开。 final修饰基本类型变量：表示该变量的值不能改变，即不能用“=”号重新赋值。final修饰引用类型变量：表示该变量的引用的地址不能变，而不是引用地址里的内容不能变。 只要满足以下条件就可以把一个类设计成final类：① 某类不是专门为继承而设计。② 出于安全考虑，类的实现细节不许改动。③ 确信该类不会再被拓展。java里final修饰的类有很多，比如八大基本数据类型包装类和String类等。 子类到底继承了父类的哪些成员: 1):SubClass类能继承SuperClass类中的public和protected成员(字段、方法、内部类)。 2):当SubClass和SuperClass类是位于同一包中，SubClass类会继承SuperClass类中的默认访问权限成员。 3):私有成员和构造器，绝对继承不到。构造器不存在继承体系中,只能调用 子类方法覆盖方法覆写的原则（一同两小一大）：一同：① 实例方法签名必须相同。 (方法签名= 方法名 + 方法的参数列表)两小：② 子类方法的返回值类型是父类方法的返回值类型的子类或相同类。③ 子类方法声明抛出的异常应比父类方法声明抛出的异常更小或相等。子类方法中声明抛出的异常小于或等于父类方法声明抛出异常类型；子类方法可以同时声明抛出多个属于父类方法声明抛出异常类的子类(RuntimeException类型除外)；一大：④ 子类方法的访问权限比父类方法访问权限更大或相等。 判断是否是覆写方法的必杀技：@Override标签：若方法是覆写方法，在方法前或上贴上该注解， 编译通过表示覆写成功，否则，编译报错。 异常异常：指的是程序在执行过程中，出现的非正常的情况，最终会导致线程的非正常停止。 异常的祖先是Throwable，有如下两个子类： Error：表示错误，错误产生后程序员不能通过代码的方式纠正，只能事先避免，好比绝症。 Exception：表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的 Throwable中的常用方法 public void printStackTrace()；打印异常的详细信息 public String getMessage()；获取发生异常的原因 finallyfinaly关键字，用于表示一个代码块。特点，无论是否有异常，最终都会执行finally代码块目的：释放资源 语法有两种： try-finally try-catch-finally 面试1):说说Error和Exception的区别. Error:是不应该使用代码来解决的错误 Exception:应该使用代码的方式来解决的异常,不解决最终导致JVM异常停止 2):final,finally,finalize的区别. final:修饰符,表示最终.修饰变量表示的是常量,值不能被修改.修饰方法表示该方法不能被子类所重写.修饰类表示的是该类不能被继承 finally:表示的是一个代码块,这个代码块的特点是无论是否有异常,都会被执行 finalize:这个是Object类上的方法,这个方法是给GC回收对象时调用的,该方法只会被调用1次,我们不要乱来 3):return和finally谁先执行. 先return在执行finally 4):无论是否有异常,finally代码块中的代码都会执行,这句话对吗? 不对,System.exit()可以退出JVM,JVM都退出了,代码怎么执行啊? 当一个方法在执行过程中,数据出现异常时,就应该使用throw抛出一个异常对象,返回给方法的调用者,异常也是一种返回类型 带异常的方法重写一同两小一大异常的总类少 异常的类型小同 子类方法覆盖 异常分类异常的分类:Exception分成两大类: 1):编译时期异常:Checked:Exception类和他的子类,除了RuntimeException家族其他的就是编译时期异常. 2):运行时期异常:Runtime: RuntimeExeption类和RuntimeException的子类. 编译时异常: 要求我们必须处理异常(throws/try-catch),不处理,则编译不能通过.运行时异常: 可处理,可不处理. 推荐使用RuntimeException. 异常的转型将编译时异常转换成运行时异常,保持异常链的传递 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 异常的转型 将编译时异常转换成运行时异常,保持异常链的传递 public static void work() &#123; try &#123; new FileInputStream(&quot;a&quot;); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e); &#125; &#125;``` ### 自定义异常建议继承 RutimeException重写 至少 3个方法 ## 构造方法子类初始化: 子类的构造器第一行必须调用父类的构造器 如果父类有默认的无参构造器，我们可以不用显示调用，编译器会帮我们在编译时加上 如果父类没有无参构造，则必须使用super手动调用父类的构造器，否则编译不能通过 ## 隐藏问题所谓隐藏就是“遮蔽”的意思。 ①满足继承的访问权限下，隐藏父类字段：若子类中定义的字段和父类中的字段名相同(不管类型)，此时就是隐藏父类字段，此时只能通过super访问被隐藏的字段。 ②隐藏本类字段：若同类中某局部变量名和字段名相同，此时就是隐藏本类字段，此时只能通过this访问被隐藏的字段。 ③满足继承的访问权限下，隐藏父类静态方法：若子类定义的静态方法的签名和父类中的静态方法签名相同，那么此时就是隐藏父类静态方法。 ## object 对象### equals 方法在非空对象引用上实现相等关系：自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。对于任何非空引用值 x，x.equals(null) 都应返回 false。Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。### hashCodepublic int hashCode()返回该对象的哈希码值。支持此方法是为了提高哈希表（例如 java.util.Hashtable 提供的哈希表）的性能。#### hashCode 的常规协定是：在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）返回：此对象的一个哈希码值。另请参见：### toStringpublic String toString()返回该对象的字符串表示。通常， toString 方法会返回一个“以文本方式表示”此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。Object 类的 toString 方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符“@”和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：getClass().getName() + &apos;@&apos; + Integer.toHexString(hashCode()) 返回：该对象的字符串表示形式## 多态父类指向了子类对象的引用的现象称为多态。 语法格式：boolean b = 对象A instanceof 类B; 注意：instanceof使用时，对象和类型之间必须是要有关系的，否则编译就报错 其实在开发中instanceof很少使用，因为在开发中，我们是知道对象的真是类型的，直接就强转了，很少去做判断 若SuperClass是SubClass的父类或其接口： 1.若doWork方法只存在于SubClass类中，不存在于SuperClass 类中。SuperClass 类型的变量不能调用到subClass中的方法 2.若doWork方法是SuperClass和SubClass类中的静态方法，此时子类doWork方法被隐藏，调用的是父类的doWork方法，此时变量obj调用doWork方法时不具备多态特征，也就不存在多态。（由于编译的时候编译器会把 调用者直接改为类） 3.若doWork方法是子类覆写父类的方法，此时变量obj调用的doWork方法实际上是子类里的doWork方法。(运行多态) ### 构造代码块直接定义在类中，与方法平行，在创建对象的时候执行。每创建一个对象执行一次 特点:优先于构造方法执行,每次实例化对象之前都会执行构造代码块。 其实编译时就是把这个代码块中的代码放到了构造方法中代码的前面。 其实就是把构造代码块中的代码放到构造方法中所有代码的前面,位于this(),super()之后 成员变量的赋值,优先于构造代码块 class Demo { String name = “a”; Demo() { System.out.println(&quot;构造方法&quot;); } //构造代码块 { System.out.println(&quot;构造代码块&quot;); } } 1编译中间代码 class Demo { String name; Demo() { name = &quot;a&quot;; System.out.println(&quot;构造代码块&quot;); System.out.println(&quot;构造方法&quot;); } } 1234## 静态代码块使用static修饰的构造代码块,称为静态代码块,用于初始化类中的静态成员变量. 其特点是: 1.当字节码被加载到JVM的时候执行 2.只会执行1次 class Demo { static int num = 100; static { System.out.println(“static .. code”); num = 10; }} ``` 抽象类在java中如果一个方法的方法体没有意义,就不应该有方法体，这种没有方法体的方法我们称为抽象方法,必须使用abstract修饰,该类中有抽象方法,就必须定义成抽象类。 使用abstract修饰且没有方法体的方法，称为抽象方法。特点：① 使用抽象abstract修饰，方法没有方法体，留给子类去实现。② 抽象方法修饰符不能是private 和 final以及static，为什么？③ 抽象方法必须定义在抽象类或接口中。 一般的：习惯性把abstract写在方法访问修饰符的后面，一看就知道是抽象方法。使用abstract关键字修饰的类。特点：① 不能创建实例即不能new一个抽象类。(不能创建对象)② 可以不包含抽象方法，若一旦包含，该类必须作为抽象类。③ 若子类没有实现父类所有的抽象方法，那么子类也得作为抽象类(抽象派生类)。④ 构造方法不能都定义成私有的，否则不能有子类(创建子类对象前先调用父类构造方法)。⑤ 抽象类不能使用final修饰，因为必须有子类，抽象方法才能得以实现。 ⑥ 是不完整的类，需作为基类，子类去拓展和实现它的功能。注意：抽象类中可以没有抽象的方法，但是有抽象方法的类一定是抽象类","categories":[{"name":"Java","slug":"Java","permalink":"https://fandyliu.github.io/categories/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"https://fandyliu.github.io/tags/基础/"},{"name":"语法","slug":"语法","permalink":"https://fandyliu.github.io/tags/语法/"}]},{"title":"Java 异常机制","slug":"Java/Java异常机制","date":"2014-04-18T12:14:23.000Z","updated":"2014-04-18T14:52:23.000Z","comments":true,"path":"2014/04/18/Java/Java异常机制/","link":"","permalink":"https://fandyliu.github.io/2014/04/18/Java/Java异常机制/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://fandyliu.github.io/categories/Java/"}],"tags":[{"name":"异常","slug":"异常","permalink":"https://fandyliu.github.io/tags/异常/"}]},{"title":"Java 设计模式","slug":"Java/Java设计模式","date":"2014-04-18T12:14:23.000Z","updated":"2014-04-18T14:52:23.000Z","comments":true,"path":"2014/04/18/Java/Java设计模式/","link":"","permalink":"https://fandyliu.github.io/2014/04/18/Java/Java设计模式/","excerpt":"","text":"总体来说设计模式分为三大类：创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 单例设计模式目的：保证某一个类在整个应用中有且只有一个实例(一个类在内存只存在一个对象)，即所有指向该类型实例的引用都指向同一块内存空间。 写单例模式的步骤：① 在类内部里显示的把所有的构造方法都使用private修饰。② 在类内部构建一个自身类型的静态字段。③ 通过一个公共的静态方法返回本类的字段。 懒汉式饿汉式 享元模式同一个类的多个对象需要平凡创建时,为了节约内存,使用缓存提前保存好一些常用的对象,要使用的时候先看缓存中是否存在,如果存在就从缓存中获取,而不创建新的对象,从而节约内存 Java 中 Intger 类型对 -128 和127 之间的数字进行了缓存","categories":[{"name":"Java","slug":"Java","permalink":"https://fandyliu.github.io/categories/Java/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://fandyliu.github.io/tags/设计模式/"}]},{"title":"Java 运行原理","slug":"Java/Java工作原理","date":"2014-03-08T13:54:13.000Z","updated":"2014-03-08T14:59:22.000Z","comments":true,"path":"2014/03/08/Java/Java工作原理/","link":"","permalink":"https://fandyliu.github.io/2014/03/08/Java/Java工作原理/","excerpt":"JVM(Java Virtual Machine）：Java 虚拟机，它是运行所有 Java 程序的虚拟计算机，用来识别和翻译字节码文件的软件。 JRE(Java Runtime Environment)：Java 运行环境，如果要运行 Java 程序，就需要 JRE 的支持，JRE里包含 JVM。 JDK(Java Development Kit)：Java开发工具，包含开发 Java 程序的所有工具，如 javac 和 java 等，JDK 里包含 JRE。","text":"JVM(Java Virtual Machine）：Java 虚拟机，它是运行所有 Java 程序的虚拟计算机，用来识别和翻译字节码文件的软件。 JRE(Java Runtime Environment)：Java 运行环境，如果要运行 Java 程序，就需要 JRE 的支持，JRE里包含 JVM。 JDK(Java Development Kit)：Java开发工具，包含开发 Java 程序的所有工具，如 javac 和 java 等，JDK 里包含 JRE。 Java 的运行原理Java 源代码是自然语言编写的不能被计算机识别，由编译器编译源代码，产生字节码文件，字节码也不是二进制的，他需要 JVM 的机器来解析。 由此可以看出 Java 即是编译型语言又是解释性语言 Java 跨平台原理通过编译器将 .java 结尾的源文件，编译为 .class 结尾的字节码文件，字节码文件可以在 JVM 上解析成二进制文件告诉操作系统，由于 JVM 在不同的系统平台中都有，从而实现跨平台。 CLASSPAT 的设置CLASSPATH：顾名思义就是 .class 文件的路径，表示JVM从哪里去寻找 .class 文件。 在 java5 之前 CLASSPATH 没有默认值，要是设置成当前路径的话，得使用“.”。 若CLASSPATH=.;d:/fandy/*，就表示先在当前目录找 .class 文件，要是没找到就去 d:/fandy/* 目录找（注意分号是英文的否则会配置失败）。 若使用 Java5 以前的版本，设置 CLASSPATH 应该是：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar其中 dt.jar 是关于运行环境的类库，主要是 swing 的包；tools.jar 是工具类库； 从 Java5 开始 CLASSPATH 默认就是当前路径，一般情况下不需再指定。 后来 SUN 公司改进了 JDK 设计，JRE 会自动搜索当前路径下的 jar 包，并自动加载 dt.jar 和 tools.jar。那么从Java5开始，就不必为设置 CLASSPATH 变量了。 JVM 内存介绍 JVM7逻辑内存划分:程序计数器：当前线程所执行的字节码的行号指示器。 本地方法栈：为虚拟机使用的 native 方法服务。 Java 虚拟机栈：描述 Java 方法执行的内存模型，每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息。 Java堆：被所有线程共享的一块内存区域，在虚拟机启动时创建。所有的对象实例以及数组都要在堆上分配，堆存储的是对象（一般使用new创建的数据就是对象）。 方法区：线程共享的内存区域，存储已被虚拟机加载的类信息、常量、静态变量即时编译器编译后的代码数据等(这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载)。 Java8 中，没有方法区，取而代之的是元数据区，其用作是和方法区一样的，但是这片内存是可以动态的跟系统申请的，当不够用时就向系统申请。 GC (Garbage Collection): 垃圾回收器。Java 的 GC 简单理解为：自动垃圾回收机制程序员就不需要再手动的去控制内存的释放。当JVM发觉内存资源紧张的时候，就会自动地去清理无用对象（没有被引用到的对象）所占用的内存空间。 我们不能控制GC 注意：并不是一产生垃圾就马上执行GC，这完全取决于JVM的调度，程序员无法控制。","categories":[{"name":"Java","slug":"Java","permalink":"https://fandyliu.github.io/categories/Java/"}],"tags":[{"name":"运行","slug":"运行","permalink":"https://fandyliu.github.io/tags/运行/"},{"name":"原理","slug":"原理","permalink":"https://fandyliu.github.io/tags/原理/"}]}]}